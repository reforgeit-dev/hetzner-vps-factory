---
# Ubuntu release upgrade role
# Deploys a self-rebooting systemd service that steps through intermediate
# releases until the target version is reached. Ansible waits for the
# completion marker, then verifies and cleans up.
#
# All post-upgrade checks use raw (no Python dependency) since release
# upgrades change the Python version and break compiled extensions.

- name: Check current Ubuntu version
  raw: lsb_release -rs 2>/dev/null | tail -1
  register: current_version
  changed_when: false

- name: Display upgrade plan
  debug:
    msg: "Current: {{ current_version.stdout | trim }} | Target: {{ ubuntu_target_version }}"

- name: Skip if already at or above target version
  meta: end_play
  when: current_version.stdout | trim is version(ubuntu_target_version, '>=')

- name: Deploy upgrade script
  template:
    src: ubuntu-release-upgrade.sh.j2
    dest: /usr/local/bin/ubuntu-release-upgrade
    mode: '0755'

- name: Deploy upgrade service
  template:
    src: ubuntu-release-upgrade.service.j2
    dest: /etc/systemd/system/ubuntu-release-upgrade.service

- name: Enable upgrade service
  systemd:
    name: ubuntu-release-upgrade
    enabled: yes
    daemon_reload: yes

- name: Start first upgrade cycle
  raw: systemctl start --no-block ubuntu-release-upgrade
  changed_when: true

- name: Upgrade in progress
  debug:
    msg: |
      WARNING: Ubuntu release upgrade is now running as a systemd service on the server.
      The upgrade continues independently even if you cancel Ansible (Ctrl+C).
      This can take 10-30+ minutes depending on the number of intermediate releases.
      The server will reboot one or more times during the process.

      Polling every 30s for up to {{ upgrade_timeout_minutes }} minutes.
      If Ansible times out, the upgrade may still be running on the server.
      Monitor on server: sudo journalctl -u ubuntu-release-upgrade -f
      Server log: /var/log/ubuntu-release-upgrade.log

# Poll for the completion marker. The server reboots between each upgrade
# step; ignore_unreachable rides through the connection drops.
# The poll command outputs current status on each attempt for visibility.
- name: Wait for upgrade to complete
  raw: |
    if [ -f /var/lib/ubuntu-upgrade-complete ]; then
      echo "DONE: $(cat /var/lib/ubuntu-upgrade-complete)"
      exit 0
    fi
    VER=$(grep VERSION_ID /etc/os-release 2>/dev/null | cut -d= -f2 | tr -d '"' || echo "?")
    SVC=$(systemctl is-active ubuntu-release-upgrade.service 2>/dev/null || echo "unknown")
    STEP=$(cat /var/lib/ubuntu-upgrade-steps 2>/dev/null || echo "?")
    echo "PENDING: version=$VER service=$SVC steps_left=$STEP"
    exit 1
  register: _upgrade_poll
  until: _upgrade_poll.rc is defined and _upgrade_poll.rc == 0
  retries: "{{ (upgrade_timeout_minutes | int * 2) }}"
  delay: 30
  changed_when: false
  ignore_unreachable: true

- name: Read completion marker
  raw: cat /var/lib/ubuntu-upgrade-complete
  register: upgrade_result
  changed_when: false

- name: Check final version
  raw: lsb_release -rs 2>/dev/null | tail -1
  register: final_version
  changed_when: false

- name: Clean up upgrade artifacts
  raw: |
    systemctl disable ubuntu-release-upgrade.service 2>/dev/null || true
    rm -f /usr/local/bin/ubuntu-release-upgrade \
          /etc/systemd/system/ubuntu-release-upgrade.service \
          /var/lib/ubuntu-upgrade-complete \
          /var/lib/ubuntu-upgrade-steps
    systemctl daemon-reload
  changed_when: true

- name: Display upgrade result
  debug:
    msg: "Ubuntu upgraded: {{ current_version.stdout | trim }} -> {{ final_version.stdout | trim }} ({{ upgrade_result.stdout | trim }})"

- name: Fail if target not reached
  fail:
    msg: |
      Target {{ ubuntu_target_version }} not reached (current: {{ final_version.stdout | trim }}).
      Result: {{ upgrade_result.stdout | trim }}
      Check server log: /var/log/ubuntu-release-upgrade.log
  when: final_version.stdout | trim is version(ubuntu_target_version, '<')
